## Общие правила разработки (Product Visor)

### Архитектура и слои
- Контроллеры: только прием/валидация входа, возврат DTO, проверка прав (через JwtUtil) и передача company или userId в сервисы. Бизнес-логика запрещена.
- Сервисы: транзакционные операции, доменная логика, вызовы других сервисов/интеграций.
- Репозитории: только доступ к данным. Никакой бизнес-логики.
- DTO: все внешние контракты через DTO. Сущности наружу не отдаём.
- Маппинг: MapStruct, отдельные мапперы на сущность. @AfterMapping для обратных ссылок.

### SOLID принципы и ответственность сервисов
- **Принцип единственной ответственности (SRP)**: Каждый сервис отвечает только за свою доменную область.
- **Валидация принадлежности сущностей**: Логика проверки принадлежности сущностей пользователю/компании должна быть в соответствующем сервисе:
  - `ProductService.validateProductOwnership()` - для проверки товаров
  - `WarehouseService.validateWarehousesOwnership()` - для проверки складов
  - `UserService.validateUserOwnership()` - для проверки пользователей
- **Запрет дублирования логики**: Не дублировать валидацию в разных сервисах. Выносить общую логику в соответствующие сервисы.
- **Инкапсуляция доменной логики**: Вся логика работы с конкретной сущностью должна быть в её сервисе.
- **Зависимость от абстракций**: Сервисы должны зависеть от других сервисов, а не от репозиториев других доменов.

### Безопасность и контекст
- JwtUtil использовать для извлечения обязательных полей: ownerUserId (JwtUtil.getRequiredOwnerId()) и effective companyId.
- Любые операции с сущностями должны проверять принадлежность текущему пользователю/компании.
- Не полагаться на client-side; валидация прав только на бэкенде.

### Каскады и целостность данных
- Использовать orphanRemoval=true для коллекций дочерних сущностей, когда жизненный цикл управляется родителем.
- Для обратных ссылок в @PrePersist/@PreUpdate устанавливать parent для всех дочерних сущностей.
- Генерация уникальных значений (например, article) должна быть инкапсулирована в сервисе.

### Обработка ошибок и логирование
- Явные сообщения об ошибках без раскрытия внутренних деталей.
- Логировать ключевые события на уровнях info/debug, ошибки на error.

### Валидация
- Использовать Bean Validation на DTO (@NotNull, @Size и т.д.) и программную валидацию в сервисе.

### Конфигурация
- Общие настройки держать в common-core, наследовать через application-common.yml.
- Не дублировать настройки в модулях без необходимости.

### Интеграции и события
- Асинхронные синхронизации – через Kafka топики, описания в common-core KafkaTopics.
- Для внешних API использовать Feign/WebClient с централизованной конфигурацией и retry-политикой.

### Тестируемость и расширяемость
- Бизнес-логика в сервисах упрощает юнит-тесты.
- Предпочитать интерфейсы для внешних интеграций, внедрение через Spring.

### Форматирование и стиль
- Следовать существующему стилю, избегать сокращений, именования по смыслу.

### Версионирование БД
- Все изменения схемы через Flyway миграции. Названия Vx__description.sql.

### Документация
- На каждый микросервис – файл с правилами, особыми соглашениями и требованиями безопасности.


