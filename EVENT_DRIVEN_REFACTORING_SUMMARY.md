# Рефакторинг StockUpdateService в Event-Driven Architecture

## Проблема

`StockUpdateService` был отдельным сервисом, который вызывался напрямую из `OrderService`. Это нарушало принцип разделения ответственности - обновление остатков является **побочным эффектом** создания/отмены заказа, а не основной бизнес-логикой.

## Решение

Рефакторинг в архитектуру событий Spring, где:
- **OrderService** публикует события о создании/отмене заказов
- **StockUpdateEventListener** обрабатывает эти события и обновляет остатки
- Обновление остатков становится **реакцией на событие**, а не прямым вызовом

## Что было сделано

### 1. Созданы события
- `OrderCreatedEvent` - событие создания заказа
- `OrderCancelledEvent` - событие отмены заказа

### 2. Создан обработчик событий
- `StockUpdateEventListener` - обрабатывает события и обновляет остатки
- Асинхронная обработка через `@Async`
- Использует общий `ProductGrpcClient` для обновления остатков

### 3. Обновлен OrderService
- Удалена зависимость от `StockUpdateService`
- Добавлена публикация событий через `ApplicationEventPublisher`
- Упрощена основная логика работы с заказами

### 4. Удален старый код
- Удален `StockUpdateService`
- Удалены прямые вызовы обновления остатков

### 5. Добавлена конфигурация
- `AsyncEventConfig` для асинхронной обработки событий
- Настроен пул потоков для обработки событий

## Архитектура до и после

### До рефакторинга:
```
OrderService.save() 
    ↓ (прямой вызов)
StockUpdateService.updateStockForOrder()
    ↓
OrderEventProducer.sendOrderCreatedEvent()
```

### После рефакторинга:
```
OrderService.save() 
    ↓ (публикация события)
OrderCreatedEvent
    ↓ (асинхронная обработка)
StockUpdateEventListener.handleOrderCreated()
    ↓
ProductGrpcClient.updateProductStockByArticle()
    ↓
OrderEventProducer.sendOrderCreatedEvent()
```

## Преимущества

### 1. Разделение ответственности
- **OrderService**: Только основная логика заказов
- **StockUpdateEventListener**: Только обновление остатков
- Четкие границы ответственности

### 2. Асинхронность
- Обработка событий не блокирует основной поток
- Улучшенная производительность
- Отказоустойчивость

### 3. Расширяемость
- Легко добавлять новые обработчики событий
- Можно обрабатывать события независимо
- Поддержка транзакций

### 4. Тестируемость
- Легко мокать события в тестах
- Изолированная логика обработки
- Четкие интерфейсы

### 5. Следование принципам
- **Single Responsibility Principle**: каждый класс имеет одну ответственность
- **Open/Closed Principle**: легко расширять без изменения существующего кода
- **Dependency Inversion**: зависимости от абстракций, а не от конкретных классов

## Использование

### Публикация событий:
```java
// В OrderService
eventPublisher.publishEvent(new OrderCreatedEvent(this, savedOrder));
eventPublisher.publishEvent(new OrderCancelledEvent(this, order));
```

### Обработка событий:
```java
// В StockUpdateEventListener
@EventListener
@Async("orderEventExecutor")
public void handleOrderCreated(OrderCreatedEvent event) {
    // Обновление остатков
    // Отправка в Kafka
}
```

## Следующие шаги

1. **Тестирование** - проверить работу новой архитектуры
2. **Мониторинг** - добавить метрики для событий
3. **Расширение** - добавить новые обработчики событий (уведомления, аналитика)
4. **Документация** - обновить API документацию

## Заключение

Рефакторинг `StockUpdateService` в архитектуру событий значительно улучшил:
- ✅ Чистоту кода и разделение ответственности
- ✅ Производительность через асинхронность
- ✅ Расширяемость и тестируемость
- ✅ Соответствие принципам SOLID

Теперь обновление остатков является **реакцией на событие** создания/отмены заказа, что соответствует правильной архитектуре событий.

